--- net/minecraft/world/entity/monster/piglin/PiglinAi.java
+++ net/minecraft/world/entity/monster/piglin/PiglinAi.java
@@ -1,0 +1,646 @@
+package net.minecraft.world.entity.monster.piglin;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.mojang.datafixers.util.Pair;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Optional;
+import java.util.Random;
+import java.util.Set;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.SerializableUUID;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.tags.ItemTags;
+import net.minecraft.util.IntRange;
+import net.minecraft.util.TimeUtil;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntitySelector;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.Mob;
+import net.minecraft.world.entity.ai.Brain;
+import net.minecraft.world.entity.ai.behavior.BackUpIfTooClose;
+import net.minecraft.world.entity.ai.behavior.BehaviorUtils;
+import net.minecraft.world.entity.ai.behavior.CopyMemoryWithExpiry;
+import net.minecraft.world.entity.ai.behavior.CrossbowAttack;
+import net.minecraft.world.entity.ai.behavior.DismountOrSkipMounting;
+import net.minecraft.world.entity.ai.behavior.DoNothing;
+import net.minecraft.world.entity.ai.behavior.EraseMemoryIf;
+import net.minecraft.world.entity.ai.behavior.GoToCelebrateLocation;
+import net.minecraft.world.entity.ai.behavior.GoToWantedItem;
+import net.minecraft.world.entity.ai.behavior.InteractWith;
+import net.minecraft.world.entity.ai.behavior.InteractWithDoor;
+import net.minecraft.world.entity.ai.behavior.LookAtTargetSink;
+import net.minecraft.world.entity.ai.behavior.MeleeAttack;
+import net.minecraft.world.entity.ai.behavior.Mount;
+import net.minecraft.world.entity.ai.behavior.MoveToTargetSink;
+import net.minecraft.world.entity.ai.behavior.RandomStroll;
+import net.minecraft.world.entity.ai.behavior.RunIf;
+import net.minecraft.world.entity.ai.behavior.RunOne;
+import net.minecraft.world.entity.ai.behavior.RunSometimes;
+import net.minecraft.world.entity.ai.behavior.SetEntityLookTarget;
+import net.minecraft.world.entity.ai.behavior.SetLookAndInteract;
+import net.minecraft.world.entity.ai.behavior.SetWalkTargetAwayFrom;
+import net.minecraft.world.entity.ai.behavior.SetWalkTargetFromAttackTargetIfTargetOutOfReach;
+import net.minecraft.world.entity.ai.behavior.SetWalkTargetFromLookTarget;
+import net.minecraft.world.entity.ai.behavior.StartAttacking;
+import net.minecraft.world.entity.ai.behavior.StartCelebratingIfTargetDead;
+import net.minecraft.world.entity.ai.behavior.StopAttackingIfTargetInvalid;
+import net.minecraft.world.entity.ai.behavior.StopBeingAngryIfTargetDead;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.entity.ai.util.RandomPos;
+import net.minecraft.world.entity.item.ItemEntity;
+import net.minecraft.world.entity.monster.hoglin.Hoglin;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.entity.schedule.Activity;
+import net.minecraft.world.item.ArmorItem;
+import net.minecraft.world.item.ArmorMaterials;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.storage.loot.BuiltInLootTables;
+import net.minecraft.world.level.storage.loot.LootContext;
+import net.minecraft.world.level.storage.loot.LootTable;
+import net.minecraft.world.level.storage.loot.parameters.LootContextParamSets;
+import net.minecraft.world.level.storage.loot.parameters.LootContextParams;
+import net.minecraft.world.phys.Vec3;
+
+public class PiglinAi {
+   protected static final Item BARTERING_ITEM;
+   private static final IntRange TIME_BETWEEN_HUNTS;
+   private static final IntRange RIDE_START_INTERVAL;
+   private static final IntRange RIDE_DURATION;
+   private static final IntRange RETREAT_DURATION;
+   private static final Set<Item> FOOD_ITEMS;
+
+   protected static Brain<?> makeBrain(Piglin var0, Brain<Piglin> var1) {
+      initCoreActivity(var1);
+      initIdleActivity(var1);
+      initAdmireItemActivity(var1);
+      initFightActivity(var0, var1);
+      initCelebrateActivity(var1);
+      initRetreatActivity(var1);
+      initRideHoglinActivity(var1);
+      var1.setCoreActivities(ImmutableSet.of(Activity.CORE));
+      var1.setDefaultActivity(Activity.IDLE);
+      var1.useDefaultActivity();
+      return var1;
+   }
+
+   protected static void initMemories(Piglin var0) {
+      int var1 = TIME_BETWEEN_HUNTS.randomValue(var0.level.random);
+      var0.getBrain().setMemoryWithExpiry(MemoryModuleType.HUNTED_RECENTLY, true, (long)var1);
+   }
+
+   private static void initCoreActivity(Brain<Piglin> var0) {
+      var0.addActivity(Activity.CORE, 0, ImmutableList.of(new LookAtTargetSink(45, 90), new MoveToTargetSink(200), new InteractWithDoor(), new StopHoldingItemIfNoLongerAdmiring(), new StartAdmiringItemIfSeen(120), new StartCelebratingIfTargetDead(300, PiglinAi::wantsToDance), new StopBeingAngryIfTargetDead()));
+   }
+
+   private static void initIdleActivity(Brain<Piglin> var0) {
+      var0.addActivity(Activity.IDLE, 10, ImmutableList.of(new SetEntityLookTarget(PiglinAi::isPlayerHoldingLovedItem, 14.0F), new StartAttacking(Piglin::isAdult, PiglinAi::findNearestValidAttackTarget), new RunIf(Piglin::canHunt, new StartHuntingHoglin()), avoidZombified(), avoidRepellent(), babySometimesRideBabyHoglin(), createIdleLookBehaviors(), createIdleMovementBehaviors(), new SetLookAndInteract(EntityType.PLAYER, 4)));
+   }
+
+   private static void initFightActivity(Piglin var0, Brain<Piglin> var1) {
+      var1.addActivityAndRemoveMemoryWhenStopped(Activity.FIGHT, 10, ImmutableList.of(new StopAttackingIfTargetInvalid((var1x) -> {
+         return !isNearestValidAttackTarget(var0, var1x);
+      }), new RunIf(PiglinAi::hasCrossbow, new BackUpIfTooClose(5, 0.75F)), new SetWalkTargetFromAttackTargetIfTargetOutOfReach(1.0F), new MeleeAttack(20), new CrossbowAttack(), new RememberIfHoglinWasKilled()), MemoryModuleType.ATTACK_TARGET);
+   }
+
+   private static void initCelebrateActivity(Brain<Piglin> var0) {
+      var0.addActivityAndRemoveMemoryWhenStopped(Activity.CELEBRATE, 10, ImmutableList.of(avoidZombified(), avoidRepellent(), new SetEntityLookTarget(PiglinAi::isPlayerHoldingLovedItem, 14.0F), new StartAttacking(Piglin::isAdult, PiglinAi::findNearestValidAttackTarget), new RunIf((var0x) -> {
+         return !var0x.isDancing();
+      }, new GoToCelebrateLocation(2, 1.0F)), new RunIf(Piglin::isDancing, new GoToCelebrateLocation(4, 0.6F)), new RunOne(ImmutableList.of(Pair.of(new SetEntityLookTarget(EntityType.PIGLIN, 8.0F), 1), Pair.of(new RandomStroll(0.6F, 2, 1), 1), Pair.of(new DoNothing(10, 20), 1)))), MemoryModuleType.CELEBRATE_LOCATION);
+   }
+
+   private static void initAdmireItemActivity(Brain<Piglin> var0) {
+      var0.addActivityAndRemoveMemoryWhenStopped(Activity.ADMIRE_ITEM, 10, ImmutableList.of(new GoToWantedItem(PiglinAi::isNotHoldingLovedItemInOffHand, 1.0F, true, 9), new StopAdmiringIfItemTooFarAway(9)), MemoryModuleType.ADMIRING_ITEM);
+   }
+
+   private static void initRetreatActivity(Brain<Piglin> var0) {
+      var0.addActivityAndRemoveMemoryWhenStopped(Activity.AVOID, 10, ImmutableList.of(SetWalkTargetAwayFrom.entity(MemoryModuleType.AVOID_TARGET, 1.1F, 6, false), createIdleLookBehaviors(), createIdleMovementBehaviors(), new EraseMemoryIf(PiglinAi::wantsToStopFleeing, MemoryModuleType.AVOID_TARGET)), MemoryModuleType.AVOID_TARGET);
+   }
+
+   private static void initRideHoglinActivity(Brain<Piglin> var0) {
+      var0.addActivityAndRemoveMemoryWhenStopped(Activity.RIDE, 10, ImmutableList.of(new Mount(0.8F), new SetEntityLookTarget(PiglinAi::isPlayerHoldingLovedItem, 8.0F), new RunIf(Entity::isPassenger, createIdleLookBehaviors()), new DismountOrSkipMounting(8, PiglinAi::wantsToStopRiding)), MemoryModuleType.RIDE_TARGET);
+   }
+
+   private static RunOne<Piglin> createIdleLookBehaviors() {
+      return new RunOne(ImmutableList.of(Pair.of(new SetEntityLookTarget(EntityType.PLAYER, 8.0F), 1), Pair.of(new SetEntityLookTarget(EntityType.PIGLIN, 8.0F), 1), Pair.of(new SetEntityLookTarget(8.0F), 1), Pair.of(new DoNothing(30, 60), 1)));
+   }
+
+   private static RunOne<Piglin> createIdleMovementBehaviors() {
+      return new RunOne(ImmutableList.of(Pair.of(new RandomStroll(0.6F), 2), Pair.of(InteractWith.of(EntityType.PIGLIN, 8, MemoryModuleType.INTERACTION_TARGET, 0.6F, 2), 2), Pair.of(new RunIf(PiglinAi::doesntSeeAnyPlayerHoldingLovedItem, new SetWalkTargetFromLookTarget(0.6F, 3)), 2), Pair.of(new DoNothing(30, 60), 1)));
+   }
+
+   private static SetWalkTargetAwayFrom<BlockPos> avoidRepellent() {
+      return SetWalkTargetAwayFrom.pos(MemoryModuleType.NEAREST_REPELLENT, 1.1F, 8, false);
+   }
+
+   private static SetWalkTargetAwayFrom<?> avoidZombified() {
+      return SetWalkTargetAwayFrom.entity(MemoryModuleType.NEAREST_VISIBLE_ZOMBIFIED, 1.1F, 10, false);
+   }
+
+   protected static void updateActivity(Piglin var0) {
+      Brain var1 = var0.getBrain();
+      Activity var2 = (Activity)var1.getActiveNonCoreActivity().orElse((Object)null);
+      var1.setActiveActivityToFirstValid(ImmutableList.of(Activity.ADMIRE_ITEM, Activity.FIGHT, Activity.AVOID, Activity.CELEBRATE, Activity.RIDE, Activity.IDLE));
+      Activity var3 = (Activity)var1.getActiveNonCoreActivity().orElse((Object)null);
+      if (var2 != var3) {
+         playActivitySound(var0);
+      }
+
+      var0.setAggressive(var1.hasMemoryValue(MemoryModuleType.ATTACK_TARGET));
+      if (!var1.hasMemoryValue(MemoryModuleType.RIDE_TARGET) && isBabyRidingBaby(var0)) {
+         var0.stopRiding();
+      }
+
+      if (!var1.hasMemoryValue(MemoryModuleType.CELEBRATE_LOCATION)) {
+         var1.eraseMemory(MemoryModuleType.DANCING);
+      }
+
+      var0.setDancing(var1.hasMemoryValue(MemoryModuleType.DANCING));
+   }
+
+   private static boolean isBabyRidingBaby(Piglin var0) {
+      if (!var0.isBaby()) {
+         return false;
+      } else {
+         Entity var1 = var0.getVehicle();
+         return var1 instanceof Piglin && ((Piglin)var1).isBaby() || var1 instanceof Hoglin && ((Hoglin)var1).isBaby();
+      }
+   }
+
+   protected static void pickUpItem(Piglin var0, ItemEntity var1) {
+      stopWalking(var0);
+      var0.take(var1, 1);
+      ItemStack var2 = removeOneItemFromItemEntity(var1);
+      Item var3 = var2.getItem();
+      if (isLovedItem(var3)) {
+         if (isHoldingItemInOffHand(var0)) {
+            var0.spawnAtLocation(var0.getItemInHand(InteractionHand.OFF_HAND));
+         }
+
+         var0.holdInOffHand(var2);
+         admireGoldItem(var0);
+      } else if (isFood(var3) && !hasEatenRecently(var0)) {
+         eat(var0);
+      } else {
+         boolean var4 = var0.equipItemIfPossible(var2);
+         if (!var4) {
+            putInInventory(var0, var2);
+         }
+      }
+   }
+
+   private static ItemStack removeOneItemFromItemEntity(ItemEntity var0) {
+      ItemStack var1 = var0.getItem();
+      ItemStack var2 = var1.split(1);
+      if (var1.isEmpty()) {
+         var0.remove();
+      } else {
+         var0.setItem(var1);
+      }
+
+      return var2;
+   }
+
+   protected static void stopHoldingOffHandItem(Piglin var0, boolean var1) {
+      ItemStack var2 = var0.getItemInHand(InteractionHand.OFF_HAND);
+      var0.setItemInHand(InteractionHand.OFF_HAND, ItemStack.EMPTY);
+      boolean var3;
+      if (var0.isAdult()) {
+         var3 = isBarterCurrency(var2.getItem());
+         if (var1 && var3) {
+            throwItems(var0, getBarterResponseItems(var0));
+         } else if (!var3) {
+            boolean var4 = var0.equipItemIfPossible(var2);
+            if (!var4) {
+               putInInventory(var0, var2);
+            }
+         }
+      } else {
+         var3 = var0.equipItemIfPossible(var2);
+         if (!var3) {
+            ItemStack var5 = var0.getMainHandItem();
+            if (isLovedItem(var5.getItem())) {
+               putInInventory(var0, var5);
+            } else {
+               throwItems(var0, Collections.singletonList(var5));
+            }
+
+            var0.holdInMainHand(var2);
+         }
+      }
+
+   }
+
+   protected static void cancelAdmiring(Piglin var0) {
+      if (isAdmiringItem(var0) && !var0.getOffhandItem().isEmpty()) {
+         var0.spawnAtLocation(var0.getOffhandItem());
+         var0.setItemInHand(InteractionHand.OFF_HAND, ItemStack.EMPTY);
+      }
+
+   }
+
+   private static void putInInventory(Piglin var0, ItemStack var1) {
+      ItemStack var2 = var0.addToInventory(var1);
+      throwItemsTowardRandomPos(var0, Collections.singletonList(var2));
+   }
+
+   private static void throwItems(Piglin var0, List<ItemStack> var1) {
+      Optional var2 = var0.getBrain().getMemory(MemoryModuleType.NEAREST_VISIBLE_PLAYER);
+      if (var2.isPresent()) {
+         throwItemsTowardPlayer(var0, (Player)var2.get(), var1);
+      } else {
+         throwItemsTowardRandomPos(var0, var1);
+      }
+
+   }
+
+   private static void throwItemsTowardRandomPos(Piglin var0, List<ItemStack> var1) {
+      throwItemsTowardPos(var0, var1, getRandomNearbyPos(var0));
+   }
+
+   private static void throwItemsTowardPlayer(Piglin var0, Player var1, List<ItemStack> var2) {
+      throwItemsTowardPos(var0, var2, var1.position());
+   }
+
+   private static void throwItemsTowardPos(Piglin var0, List<ItemStack> var1, Vec3 var2) {
+      if (!var1.isEmpty()) {
+         var0.swing(InteractionHand.OFF_HAND);
+         Iterator var3 = var1.iterator();
+
+         while(var3.hasNext()) {
+            ItemStack var4 = (ItemStack)var3.next();
+            BehaviorUtils.throwItem(var0, var4, var2.add(0.0D, 1.0D, 0.0D));
+         }
+      }
+
+   }
+
+   private static List<ItemStack> getBarterResponseItems(Piglin var0) {
+      LootTable var1 = var0.level.getServer().getLootTables().get(BuiltInLootTables.PIGLIN_BARTERING);
+      List var2 = var1.getRandomItems((new LootContext.Builder((ServerLevel)var0.level)).withParameter(LootContextParams.THIS_ENTITY, var0).withRandom(var0.level.random).create(LootContextParamSets.PIGLIN_BARTER));
+      return var2;
+   }
+
+   private static boolean wantsToDance(LivingEntity var0, LivingEntity var1) {
+      if (var1.getType() != EntityType.HOGLIN) {
+         return false;
+      } else {
+         return (new Random(var0.level.getGameTime())).nextFloat() < 0.1F;
+      }
+   }
+
+   protected static boolean wantsToPickup(Piglin var0, ItemStack var1) {
+      Item var2 = var1.getItem();
+      if (var2.is(ItemTags.PIGLIN_REPELLENTS)) {
+         return false;
+      } else if (isAdmiringDisabled(var0) && var0.getBrain().hasMemoryValue(MemoryModuleType.ATTACK_TARGET)) {
+         return false;
+      } else if (isBarterCurrency(var2)) {
+         return isNotHoldingLovedItemInOffHand(var0);
+      } else {
+         boolean var3 = var0.canAddToInventory(var1);
+         if (var2 == Items.GOLD_NUGGET) {
+            return var3;
+         } else if (isFood(var2)) {
+            return !hasEatenRecently(var0) && var3;
+         } else if (!isLovedItem(var2)) {
+            return var0.canReplaceCurrentItem(var1);
+         } else {
+            return isNotHoldingLovedItemInOffHand(var0) && var3;
+         }
+      }
+   }
+
+   protected static boolean isLovedItem(Item var0) {
+      return var0.is(ItemTags.PIGLIN_LOVED);
+   }
+
+   private static boolean wantsToStopRiding(Piglin var0, Entity var1) {
+      if (!(var1 instanceof Mob)) {
+         return false;
+      } else {
+         Mob var2 = (Mob)var1;
+         return !var2.isBaby() || !var2.isAlive() || wasHurtRecently(var0) || wasHurtRecently(var2) || var2 instanceof Piglin && var2.getVehicle() == null;
+      }
+   }
+
+   private static boolean isNearestValidAttackTarget(Piglin var0, LivingEntity var1) {
+      return findNearestValidAttackTarget(var0).filter((var1x) -> {
+         return var1x == var1;
+      }).isPresent();
+   }
+
+   private static Optional<? extends LivingEntity> findNearestValidAttackTarget(Piglin var0) {
+      Brain var1 = var0.getBrain();
+      Optional var2 = BehaviorUtils.getLivingEntityFromUUIDMemory(var0, MemoryModuleType.ANGRY_AT);
+      if (var2.isPresent() && isAttackAllowed((LivingEntity)var2.get())) {
+         return var2;
+      } else {
+         Optional var3 = var1.getMemory(MemoryModuleType.NEAREST_VISIBLE_WITHER_SKELETON);
+         if (var3.isPresent()) {
+            return var3;
+         } else {
+            Optional var4 = var1.getMemory(MemoryModuleType.NEAREST_TARGETABLE_PLAYER_NOT_WEARING_GOLD);
+            return var4.isPresent() && isAttackAllowed((LivingEntity)var4.get()) ? var4 : Optional.empty();
+         }
+      }
+   }
+
+   public static void angerNearbyPiglinsThatSee(Player var0) {
+      if (isAttackAllowed(var0)) {
+         List var1 = var0.level.getEntitiesOfClass(Piglin.class, var0.getBoundingBox().inflate(16.0D));
+         var1.stream().filter(PiglinAi::isIdle).filter((var1x) -> {
+            return BehaviorUtils.canSee(var1x, var0);
+         }).forEach((var1x) -> {
+            setAngerTarget(var1x, var0);
+         });
+      }
+   }
+
+   public static boolean mobInteract(Piglin var0, Player var1, InteractionHand var2) {
+      ItemStack var3 = var1.getItemInHand(var2);
+      if (canAdmire(var0, var3)) {
+         ItemStack var4 = var3.split(1);
+         var0.holdInOffHand(var4);
+         admireGoldItem(var0);
+         return true;
+      } else {
+         return false;
+      }
+   }
+
+   protected static boolean canAdmire(Piglin var0, ItemStack var1) {
+      return !isAdmiringDisabled(var0) && !isAdmiringItem(var0) && var0.isAdult() && isBarterCurrency(var1.getItem());
+   }
+
+   protected static void wasHurtBy(Piglin var0, LivingEntity var1) {
+      if (!(var1 instanceof Piglin)) {
+         if (isHoldingItemInOffHand(var0)) {
+            stopHoldingOffHandItem(var0, false);
+         }
+
+         Brain var2 = var0.getBrain();
+         var2.eraseMemory(MemoryModuleType.CELEBRATE_LOCATION);
+         var2.eraseMemory(MemoryModuleType.DANCING);
+         var2.eraseMemory(MemoryModuleType.ADMIRING_ITEM);
+         if (var1 instanceof Player) {
+            var2.setMemoryWithExpiry(MemoryModuleType.ADMIRING_DISABLED, true, 400L);
+         }
+
+         if (var0.isBaby()) {
+            var2.setMemoryWithExpiry(MemoryModuleType.AVOID_TARGET, var1, 100L);
+            if (isAttackAllowed(var1)) {
+               broadcastAngerTarget(var0, var1);
+            }
+
+         } else if (var1.getType() == EntityType.HOGLIN && hoglinsOutnumberPiglins(var0)) {
+            setAvoidTargetAndDontHuntForAWhile(var0, var1);
+            broadcastRetreat(var0, var1);
+         } else {
+            maybeRetaliate(var0, var1);
+         }
+      }
+   }
+
+   private static void maybeRetaliate(Piglin var0, LivingEntity var1) {
+      if (!var0.getBrain().isActive(Activity.AVOID) || var1.getType() != EntityType.HOGLIN) {
+         if (isAttackAllowed(var1)) {
+            if (!BehaviorUtils.isOtherTargetMuchFurtherAwayThanCurrentAttackTarget(var0, var1, 4.0D)) {
+               setAngerTarget(var0, var1);
+               broadcastAngerTarget(var0, var1);
+            }
+         }
+      }
+   }
+
+   private static void playActivitySound(Piglin var0) {
+      var0.getBrain().getActiveNonCoreActivity().ifPresent((var1) -> {
+         if (var1 == Activity.FIGHT) {
+            var0.playAngrySound();
+         } else if (var1 != Activity.AVOID && !var0.isConverting()) {
+            if (var1 == Activity.ADMIRE_ITEM) {
+               var0.playAdmiringSound();
+            } else if (var1 == Activity.CELEBRATE) {
+               var0.playCelebrateSound();
+            } else if (seesPlayerHoldingLovedItem(var0)) {
+               var0.playJealousSound();
+            } else if (seesZombifiedPiglin(var0) || seesRepellent(var0)) {
+               var0.playRetreatSound();
+            }
+         } else {
+            var0.playRetreatSound();
+         }
+
+      });
+   }
+
+   protected static void maybePlayActivitySound(Piglin var0) {
+      if ((double)var0.level.random.nextFloat() < 0.0125D) {
+         playActivitySound(var0);
+      }
+
+   }
+
+   protected static boolean hasAnyoneNearbyHuntedRecently(Piglin var0) {
+      return var0.getBrain().hasMemoryValue(MemoryModuleType.HUNTED_RECENTLY) || getVisibleAdultPiglins(var0).stream().anyMatch((var0x) -> {
+         return var0x.getBrain().hasMemoryValue(MemoryModuleType.HUNTED_RECENTLY);
+      });
+   }
+
+   private static List<Piglin> getVisibleAdultPiglins(Piglin var0) {
+      return (List)var0.getBrain().getMemory(MemoryModuleType.NEAREST_VISIBLE_ADULT_PIGLINS).orElse(ImmutableList.of());
+   }
+
+   private static List<Piglin> getAdultPiglins(Piglin var0) {
+      return (List)var0.getBrain().getMemory(MemoryModuleType.NEAREST_ADULT_PIGLINS).orElse(ImmutableList.of());
+   }
+
+   public static boolean isWearingGold(LivingEntity var0) {
+      Iterable var1 = var0.getArmorSlots();
+      Iterator var2 = var1.iterator();
+
+      Item var4;
+      do {
+         if (!var2.hasNext()) {
+            return false;
+         }
+
+         ItemStack var3 = (ItemStack)var2.next();
+         var4 = var3.getItem();
+      } while(!(var4 instanceof ArmorItem) || ((ArmorItem)var4).getMaterial() != ArmorMaterials.GOLD);
+
+      return true;
+   }
+
+   private static void stopWalking(Piglin var0) {
+      var0.getBrain().eraseMemory(MemoryModuleType.WALK_TARGET);
+      var0.getNavigation().stop();
+   }
+
+   private static RunSometimes<Piglin> babySometimesRideBabyHoglin() {
+      return new RunSometimes(new CopyMemoryWithExpiry(Piglin::isBaby, MemoryModuleType.NEAREST_VISIBLE_BABY_HOGLIN, MemoryModuleType.RIDE_TARGET, RIDE_DURATION), RIDE_START_INTERVAL);
+   }
+
+   protected static void broadcastAngerTarget(Piglin var0, LivingEntity var1) {
+      getAdultPiglins(var0).forEach((var1x) -> {
+         if (var1.getType() != EntityType.HOGLIN || var1x.canHunt() && ((Hoglin)var1).canBeHunted()) {
+            setAngerTargetIfCloserThanCurrent(var1x, var1);
+         }
+      });
+   }
+
+   protected static void broadcastDontKillAnyMoreHoglinsForAWhile(Piglin var0) {
+      getVisibleAdultPiglins(var0).forEach(PiglinAi::dontKillAnyMoreHoglinsForAWhile);
+   }
+
+   protected static void setAngerTarget(Piglin var0, LivingEntity var1) {
+      var0.getBrain().eraseMemory(MemoryModuleType.CANT_REACH_WALK_TARGET_SINCE);
+      var0.getBrain().setMemoryWithExpiry(MemoryModuleType.ANGRY_AT, new SerializableUUID(var1.getUUID()), 600L);
+      if (var1.getType() == EntityType.HOGLIN) {
+         dontKillAnyMoreHoglinsForAWhile(var0);
+      }
+
+   }
+
+   private static void setAngerTargetIfCloserThanCurrent(Piglin var0, LivingEntity var1) {
+      Optional var2 = getAngerTarget(var0);
+      LivingEntity var3 = BehaviorUtils.getNearestTarget(var0, var2, var1);
+      if (!var2.isPresent() || var2.get() != var3) {
+         setAngerTarget(var0, var3);
+      }
+   }
+
+   private static Optional<LivingEntity> getAngerTarget(Piglin var0) {
+      return BehaviorUtils.getLivingEntityFromUUIDMemory(var0, MemoryModuleType.ANGRY_AT);
+   }
+
+   private static void broadcastRetreat(Piglin var0, LivingEntity var1) {
+      getVisibleAdultPiglins(var0).forEach((var1x) -> {
+         retreatFromNearestTarget(var1x, var1);
+      });
+   }
+
+   private static void retreatFromNearestTarget(Piglin var0, LivingEntity var1) {
+      Brain var2 = var0.getBrain();
+      LivingEntity var3 = BehaviorUtils.getNearestTarget(var0, var2.getMemory(MemoryModuleType.AVOID_TARGET), var1);
+      var3 = BehaviorUtils.getNearestTarget(var0, var2.getMemory(MemoryModuleType.ATTACK_TARGET), var3);
+      setAvoidTargetAndDontHuntForAWhile(var0, var3);
+   }
+
+   private static boolean wantsToStopFleeing(Piglin var0) {
+      return var0.isAdult() && piglinsEqualOrOutnumberHoglins(var0);
+   }
+
+   private static boolean piglinsEqualOrOutnumberHoglins(Piglin var0) {
+      return !hoglinsOutnumberPiglins(var0);
+   }
+
+   private static boolean hoglinsOutnumberPiglins(Piglin var0) {
+      int var1 = (Integer)var0.getBrain().getMemory(MemoryModuleType.VISIBLE_ADULT_PIGLIN_COUNT).orElse(0) + 1;
+      int var2 = (Integer)var0.getBrain().getMemory(MemoryModuleType.VISIBLE_ADULT_HOGLIN_COUNT).orElse(0);
+      return var2 > var1;
+   }
+
+   private static void setAvoidTargetAndDontHuntForAWhile(Piglin var0, LivingEntity var1) {
+      var0.getBrain().eraseMemory(MemoryModuleType.ANGRY_AT);
+      var0.getBrain().eraseMemory(MemoryModuleType.ATTACK_TARGET);
+      var0.getBrain().setMemoryWithExpiry(MemoryModuleType.AVOID_TARGET, var1, (long)RETREAT_DURATION.randomValue(var0.level.random));
+      dontKillAnyMoreHoglinsForAWhile(var0);
+   }
+
+   protected static void dontKillAnyMoreHoglinsForAWhile(Piglin var0) {
+      var0.getBrain().setMemoryWithExpiry(MemoryModuleType.HUNTED_RECENTLY, true, (long)TIME_BETWEEN_HUNTS.randomValue(var0.level.random));
+   }
+
+   private static void eat(Piglin var0) {
+      var0.getBrain().setMemoryWithExpiry(MemoryModuleType.ATE_RECENTLY, true, 200L);
+   }
+
+   private static Vec3 getRandomNearbyPos(Piglin var0) {
+      Vec3 var1 = RandomPos.getLandPos(var0, 4, 2);
+      return var1 == null ? var0.position() : var1;
+   }
+
+   private static boolean hasEatenRecently(Piglin var0) {
+      return var0.getBrain().hasMemoryValue(MemoryModuleType.ATE_RECENTLY);
+   }
+
+   protected static boolean isIdle(Piglin var0) {
+      return var0.getBrain().isActive(Activity.IDLE);
+   }
+
+   private static boolean hasCrossbow(LivingEntity var0) {
+      return var0.isHolding(Items.CROSSBOW);
+   }
+
+   private static void admireGoldItem(LivingEntity var0) {
+      var0.getBrain().setMemoryWithExpiry(MemoryModuleType.ADMIRING_ITEM, true, 120L);
+   }
+
+   private static boolean isAdmiringItem(Piglin var0) {
+      return var0.getBrain().hasMemoryValue(MemoryModuleType.ADMIRING_ITEM);
+   }
+
+   private static boolean isBarterCurrency(Item var0) {
+      return var0 == BARTERING_ITEM;
+   }
+
+   private static boolean isFood(Item var0) {
+      return FOOD_ITEMS.contains(var0);
+   }
+
+   private static boolean isAttackAllowed(LivingEntity var0) {
+      return EntitySelector.ATTACK_ALLOWED.test(var0);
+   }
+
+   private static boolean seesRepellent(Piglin var0) {
+      return var0.getBrain().hasMemoryValue(MemoryModuleType.NEAREST_REPELLENT);
+   }
+
+   private static boolean seesZombifiedPiglin(Piglin var0) {
+      return var0.getBrain().hasMemoryValue(MemoryModuleType.NEAREST_VISIBLE_ZOMBIFIED);
+   }
+
+   private static boolean seesPlayerHoldingLovedItem(LivingEntity var0) {
+      return var0.getBrain().hasMemoryValue(MemoryModuleType.NEAREST_PLAYER_HOLDING_WANTED_ITEM);
+   }
+
+   private static boolean doesntSeeAnyPlayerHoldingLovedItem(LivingEntity var0) {
+      return !seesPlayerHoldingLovedItem(var0);
+   }
+
+   public static boolean isPlayerHoldingLovedItem(LivingEntity var0) {
+      return var0.getType() == EntityType.PLAYER && var0.isHolding(PiglinAi::isLovedItem);
+   }
+
+   private static boolean isAdmiringDisabled(Piglin var0) {
+      return var0.getBrain().hasMemoryValue(MemoryModuleType.ADMIRING_DISABLED);
+   }
+
+   private static boolean wasHurtRecently(LivingEntity var0) {
+      return var0.getBrain().hasMemoryValue(MemoryModuleType.HURT_BY);
+   }
+
+   private static boolean isHoldingItemInOffHand(Piglin var0) {
+      return !var0.getOffhandItem().isEmpty();
+   }
+
+   private static boolean isNotHoldingLovedItemInOffHand(Piglin var0) {
+      return var0.getOffhandItem().isEmpty() || !isLovedItem(var0.getOffhandItem().getItem());
+   }
+
+   static {
+      BARTERING_ITEM = Items.GOLD_INGOT;
+      TIME_BETWEEN_HUNTS = TimeUtil.rangeOfSeconds(30, 120);
+      RIDE_START_INTERVAL = TimeUtil.rangeOfSeconds(10, 40);
+      RIDE_DURATION = TimeUtil.rangeOfSeconds(10, 30);
+      RETREAT_DURATION = TimeUtil.rangeOfSeconds(5, 20);
+      FOOD_ITEMS = ImmutableSet.of(Items.PORKCHOP, Items.COOKED_PORKCHOP);
+   }
+}
