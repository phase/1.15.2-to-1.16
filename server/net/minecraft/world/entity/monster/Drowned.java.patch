--- net/minecraft/world/entity/monster/Drowned.java
+++ net/minecraft/world/entity/monster/Drowned.java
@@ -18,10 +18,11 @@
 import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.entity.MobSpawnType;
 import net.minecraft.world.entity.MoverType;
 import net.minecraft.world.entity.PathfinderMob;
 import net.minecraft.world.entity.SpawnGroupData;
+import net.minecraft.world.entity.ai.attributes.Attributes;
 import net.minecraft.world.entity.ai.control.MoveControl;
 import net.minecraft.world.entity.ai.goal.Goal;
 import net.minecraft.world.entity.ai.goal.MoveToBlockGoal;
 import net.minecraft.world.entity.ai.goal.RandomStrollGoal;
 import net.minecraft.world.entity.ai.goal.RangedAttackGoal;
@@ -67,11 +68,11 @@
       this.goalSelector.addGoal(2, new Drowned.DrownedTridentAttackGoal(this, 1.0D, 40, 10.0F));
       this.goalSelector.addGoal(2, new Drowned.DrownedAttackGoal(this, 1.0D, false));
       this.goalSelector.addGoal(5, new Drowned.DrownedGoToBeachGoal(this, 1.0D));
       this.goalSelector.addGoal(6, new Drowned.DrownedSwimUpGoal(this, 1.0D, this.level.getSeaLevel()));
       this.goalSelector.addGoal(7, new RandomStrollGoal(this, 1.0D));
-      this.targetSelector.addGoal(1, (new HurtByTargetGoal(this, new Class[]{Drowned.class})).setAlertOthers(PigZombie.class));
+      this.targetSelector.addGoal(1, (new HurtByTargetGoal(this, new Class[]{Drowned.class})).setAlertOthers(ZombifiedPiglin.class));
       this.targetSelector.addGoal(2, new NearestAttackableTargetGoal(this, Player.class, 10, true, false, this::okTarget));
       this.targetSelector.addGoal(3, new NearestAttackableTargetGoal(this, AbstractVillager.class, false));
       this.targetSelector.addGoal(3, new NearestAttackableTargetGoal(this, IronGolem.class, true));
       this.targetSelector.addGoal(5, new NearestAttackableTargetGoal(this, Turtle.class, 10, true, false, Turtle.BABY_ON_LAND_SELECTOR));
    }
@@ -138,21 +139,21 @@
          }
       }
 
    }
 
-   protected boolean canReplaceCurrentItem(ItemStack var1, ItemStack var2, EquipmentSlot var3) {
+   protected boolean canReplaceCurrentItem(ItemStack var1, ItemStack var2) {
       if (var2.getItem() == Items.NAUTILUS_SHELL) {
          return false;
       } else if (var2.getItem() == Items.TRIDENT) {
          if (var1.getItem() == Items.TRIDENT) {
             return var1.getDamageValue() < var2.getDamageValue();
          } else {
             return false;
          }
       } else {
-         return var1.getItem() == Items.TRIDENT ? true : super.canReplaceCurrentItem(var1, var2, var3);
+         return var1.getItem() == Items.TRIDENT ? true : super.canReplaceCurrentItem(var1, var2);
       }
    }
 
    protected boolean convertsInWater() {
       return false;
@@ -168,11 +169,11 @@
       } else {
          return false;
       }
    }
 
-   public boolean isPushedByWater() {
+   public boolean isPushedByFluid() {
       return !this.isSwimming();
    }
 
    private boolean wantsToSwim() {
       if (this.searchingForLand) {
@@ -263,11 +264,11 @@
             double var8 = (double)Mth.sqrt(var2 * var2 + var4 * var4 + var6 * var6);
             var4 /= var8;
             float var10 = (float)(Mth.atan2(var6, var2) * 57.2957763671875D) - 90.0F;
             this.drowned.yRot = this.rotlerp(this.drowned.yRot, var10, 90.0F);
             this.drowned.yBodyRot = this.drowned.yRot;
-            float var11 = (float)(this.speedModifier * this.drowned.getAttribute(SharedMonsterAttributes.MOVEMENT_SPEED).getValue());
+            float var11 = (float)(this.speedModifier * this.drowned.getAttributeValue(Attributes.MOVEMENT_SPEED));
             float var12 = Mth.lerp(0.125F, this.drowned.getSpeed(), var11);
             this.drowned.setSpeed(var12);
             this.drowned.setDeltaMovement(this.drowned.getDeltaMovement().add((double)var12 * var2 * 0.005D, (double)var12 * var4 * 0.1D, (double)var12 * var6 * 0.005D));
          } else {
             if (!this.drowned.onGround) {
@@ -339,16 +340,16 @@
       }
 
       @Nullable
       private Vec3 getWaterPos() {
          Random var1 = this.mob.getRandom();
-         BlockPos var2 = new BlockPos(this.mob);
+         BlockPos var2 = this.mob.blockPosition();
 
          for(int var3 = 0; var3 < 10; ++var3) {
             BlockPos var4 = var2.offset(var1.nextInt(20) - 10, 2 - var1.nextInt(8), var1.nextInt(20) - 10);
-            if (this.level.getBlockState(var4).getBlock() == Blocks.WATER) {
-               return new Vec3(var4);
+            if (this.level.getBlockState(var4).is(Blocks.WATER)) {
+               return Vec3.atBottomCenterOf(var4);
             }
          }
 
          return null;
       }
