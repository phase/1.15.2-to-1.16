--- net/minecraft/world/level/pathfinder/PathFinder.java
+++ net/minecraft/world/level/pathfinder/PathFinder.java
@@ -2,10 +2,11 @@
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import java.util.ArrayList;
 import java.util.Comparator;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
 import java.util.function.Function;
@@ -15,15 +16,14 @@
 import net.minecraft.core.BlockPos;
 import net.minecraft.world.entity.Mob;
 import net.minecraft.world.level.PathNavigationRegion;
 
 public class PathFinder {
-   private final BinaryHeap openSet = new BinaryHeap();
-   private final Set<Node> closedSet = Sets.newHashSet();
    private final Node[] neighbors = new Node[32];
    private final int maxVisitedNodes;
    private final NodeEvaluator nodeEvaluator;
+   private final BinaryHeap openSet = new BinaryHeap();
 
    public PathFinder(NodeEvaluator var1, int var2) {
       this.nodeEvaluator = var1;
       this.maxVisitedNodes = var2;
    }
@@ -46,70 +46,70 @@
       Set var6 = var2.keySet();
       var1.g = 0.0F;
       var1.h = this.getBestH(var1, var6);
       var1.f = var1.h;
       this.openSet.clear();
-      this.closedSet.clear();
       this.openSet.insert(var1);
-      int var7 = 0;
-      int var8 = (int)((float)this.maxVisitedNodes * var5);
+      HashSet var7 = Sets.newHashSet();
+      int var8 = 0;
+      int var9 = (int)((float)this.maxVisitedNodes * var5);
 
       while(!this.openSet.isEmpty()) {
-         ++var7;
-         if (var7 >= var8) {
+         ++var8;
+         if (var8 >= var9) {
             break;
          }
 
-         Node var9 = this.openSet.pop();
-         var9.closed = true;
+         Node var10 = this.openSet.pop();
+         var10.closed = true;
          var6.stream().filter((var2x) -> {
-            return var9.distanceManhattan((Node)var2x) <= (float)var4;
+            return var10.distanceManhattan((Node)var2x) <= (float)var4;
          }).forEach(Target::setReached);
          if (var6.stream().anyMatch(Target::isReached)) {
             break;
          }
 
-         if (var9.distanceTo(var1) < var3) {
-            int var10 = this.nodeEvaluator.getNeighbors(this.neighbors, var9);
+         if (var10.distanceTo(var1) < var3) {
+            int var11 = this.nodeEvaluator.getNeighbors(this.neighbors, var10);
 
-            for(int var11 = 0; var11 < var10; ++var11) {
-               Node var12 = this.neighbors[var11];
-               float var13 = var9.distanceTo(var12);
-               var12.walkedDistance = var9.walkedDistance + var13;
-               float var14 = var9.g + var13 + var12.costMalus;
-               if (var12.walkedDistance < var3 && (!var12.inOpenSet() || var14 < var12.g)) {
-                  var12.cameFrom = var9;
-                  var12.g = var14;
-                  var12.h = this.getBestH(var12, var6) * 1.5F;
-                  if (var12.inOpenSet()) {
-                     this.openSet.changeCost(var12, var12.g + var12.h);
+            for(int var12 = 0; var12 < var11; ++var12) {
+               Node var13 = this.neighbors[var12];
+               float var14 = var10.distanceTo(var13);
+               var13.walkedDistance = var10.walkedDistance + var14;
+               float var15 = var10.g + var14 + var13.costMalus;
+               if (var13.walkedDistance < var3 && (!var13.inOpenSet() || var15 < var13.g)) {
+                  var13.cameFrom = var10;
+                  var13.g = var15;
+                  var13.h = this.getBestH(var13, var6) * 1.5F;
+                  if (var13.inOpenSet()) {
+                     this.openSet.changeCost(var13, var13.g + var13.h);
                   } else {
-                     var12.f = var12.g + var12.h;
-                     this.openSet.insert(var12);
+                     var13.f = var13.g + var13.h;
+                     this.openSet.insert(var13);
                   }
                }
             }
          }
       }
 
-      Stream var15;
+      Stream var16;
       if (var6.stream().anyMatch(Target::isReached)) {
-         var15 = var6.stream().filter(Target::isReached).map((var2x) -> {
+         var16 = var6.stream().filter(Target::isReached).map((var2x) -> {
             return this.reconstructPath(var2x.getBestNode(), (BlockPos)var2.get(var2x), true);
          }).sorted(Comparator.comparingInt(Path::getSize));
       } else {
-         var15 = var6.stream().map((var2x) -> {
+         var16 = var6.stream().map((var2x) -> {
             return this.reconstructPath(var2x.getBestNode(), (BlockPos)var2.get(var2x), false);
          }).sorted(Comparator.comparingDouble(Path::getDistToTarget).thenComparingInt(Path::getSize));
       }
 
-      Optional var16 = var15.findFirst();
-      if (!var16.isPresent()) {
+      Optional var17 = var16.findFirst();
+      if (!var17.isPresent()) {
          return null;
       } else {
-         Path var17 = (Path)var16.get();
-         return var17;
+         Path var18 = (Path)var17.get();
+         return var18;
       }
    }
 
    private float getBestH(Node var1, Set<Target> var2) {
       float var3 = Float.MAX_VALUE;
